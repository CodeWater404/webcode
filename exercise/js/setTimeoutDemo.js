//1. 先等同步任务执行完成后，再执行异步任务。
// console.log(11)
// setTimeout(() => {
//     console.log("22")
// }, 1000)

// console.log(33)
// console.log(44)
/*
11
33
44
22
*/

//2. 先等同步任务执行完成后，再执行异步任务。========================重要==============================
// console.log(11)
// setTimeout(() => {
//     console.log(22)
// }, 0)
// console.log(33)
// console.log(44)
/*22还是最后输出
11
33
44
22
*/

//3. 下面这个异步任务不是 2 秒之后执行，而是等耗时的同步任务执行完毕之后，才执行。
// setTimeout(() => {
//     console.log('异步任务');
// }, 2000);

// // 伪代码
// sleep(5000); //表示很耗时的同步任务，注意这里不是内建的函数，只是一个伪代码

// 4. 上面的代码中，等到 1 秒之后，真的会执行异步任务吗？其实不是。
// 在浏览器中， setTimeout()/ setInterval() 的每调用一次定时器的最小时间间隔是4毫秒，这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的 setInterval 的回调函数阻塞导致的。
// 上面的案例中，异步任务需要等待 1004 毫秒之后，才会从 Event Table 进入到 Event Queue。这在面试中也经常被问到。
setTimeout(() => {
    console.log('异步任务');
}, 1000);